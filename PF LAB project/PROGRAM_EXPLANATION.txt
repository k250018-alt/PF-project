================================================================================
                        CAR GAME - PROGRAM EXPLANATION
================================================================================

OVERVIEW
========
This is a GTK3-based racing/dodging game written in C. The player controls a car
using arrow keys or WASD, navigating it down the screen while avoiding falling
obstacles. The game keeps score, tracks a high score (saved to highscore.txt),
and features multiple menus (Main, Pause, Game Over, Controls) with clickable
buttons and keyboard shortcuts.

KEY FEATURES
============
- Player-controlled car sprite with smooth rotation-based movement
- Multiple obstacle types (bags, barrels) spawning randomly
- Scrolling background that loops seamlessly
- High score persistence (saved to highscore.txt)
- Progressive difficulty: obstacles speed up and spawn more frequently as score increases
- Pause/Resume functionality (ESC or P key)
- Main Menu, Controls screen, Game Over screen with functional buttons
- Mouse hover effects on menu buttons
- Collision detection with slightly inset hitboxes for fair gameplay
- Smooth 60 FPS gameplay loop

FILE STRUCTURE
==============
Project Root: c:\Users\User\Desktop\PF LAB project\
│
├── src/
│   ├── main.c           - Entry point; creates and runs the game
│   ├── game.c           - Core game state, loop, update, collision logic
│   ├── player.c         - Player (car) physics and rendering
│   ├── obstacle.c       - Obstacle spawning, movement, and management
│   └── graphics.c       - Drawing utilities (text, shapes, images)
│
├── include/
│   ├── game.h           - Game state structures and function declarations
│   ├── player.h         - Player structure and function declarations
│   ├── obstacle.h       - Obstacle/ObstacleManager structures
│   └── graphics.h       - Graphics functions and color definitions
│
├── build/
│   ├── compile.sh       - MSYS2/bash build script (gcc + pkg-config)
│   ├── car_game.exe     - Compiled executable (generated by build script)
│   └── [cmake files]    - Leftover from old build system (can be ignored)
│
├── assets/
│   ├── car_rotated.png  - Player car sprite (rotated 90 degrees from original)
│   ├── obj_bags1.png    - Obstacle variant (bags)
│   ├── obj_barrel1.png  - Obstacle variant (barrel type 1)
│   ├── obj_barrel2.png  - Obstacle variant (barrel type 2)
│   ├── obj_barrels.png  - Obstacle variant (multiple barrels)
│   └── background-1.png - Scrolling background image
│
├── rebuild_and_test.bat - Windows batch helper to rebuild and launch game
├── rotate.ps1           - PowerShell script to rotate PNG images
├── rotate.bat           - Batch wrapper for rotate.ps1
├── highscore.txt        - Persisted high score (created at first game over)
├── Car Game.lnk         - Desktop shortcut to launch car_game.exe
└── PROGRAM_EXPLANATION.txt - This file

CODE ARCHITECTURE
=================

1. ENTRY POINT (src/main.c)
   ├─ main() creates a GTK window and game instance
   ├─ Initializes the game with game_init()
   ├─ Calls game_start() to begin the main loop
   └─ Runs gtk_main() which processes events and calls game_loop() every 16.67ms

2. GAME LOOP & STATE MANAGEMENT (src/game.c)
   Key structures:
   ├─ GameState: Holds score, level, highscore, screen_state (MENU/PLAYING/PAUSED/GAME_OVER)
   └─ Game: Holds window, drawing_area, key state, menu selection, timer ID
   
   Key functions:
   ├─ game_loop() - Called every frame (16.67ms at 60 FPS)
   │  ├─ Processes input (always, for menu responsiveness)
   │  ├─ If PLAYING: calls game_update() to advance physics/score/collisions
   │  ├─ If PLAYING: advances background scroll
   │  └─ Queues redraw for draw_callback()
   │
   ├─ game_update() - Core game logic
   │  ├─ Updates player position and velocity (physics)
   │  ├─ Updates and spawns obstacles
   │  ├─ Checks collisions and triggers GAME_OVER if hit
   │  ├─ Increments score (frame-rate independent accumulation)
   │  ├─ Checks if high score beaten and persists it
   │  └─ Increases difficulty (speed, spawn rate) every 1000 points
   │
   ├─ draw_callback() - Renders current frame
   │  ├─ Draws scrolling background (loops seamlessly)
   │  ├─ Based on screen_state:
   │  │  ├─ MENU: draw_main_menu()
   │  │  ├─ PLAYING: draws player + obstacles + HUD text
   │  │  ├─ PAUSED: draws pause menu overlay
   │  │  ├─ CONTROLS: draws control instructions
   │  │  └─ GAME_OVER: draws game over menu with scores and buttons
   │  └─ HUD text includes: score, high score, level, debug info
   │
   ├─ key_press_handler() / key_release_handler()
   │  ├─ Tracks which keys are held (Left, Right, Up, Down, Space, ESC, P, Enter)
   │  ├─ PLAYING: Arrow keys control car; ESC/P pauses; Space restarts
   │  ├─ MENU: Up/Down select menu item; Space activates; ESC quits
   │  ├─ PAUSED: Space resumes; ESC goes to menu
   │  └─ GAME_OVER: Space restarts; ESC goes to menu
   │
   ├─ button_press_handler() / motion_notify_handler()
   │  ├─ Mouse clicks on menu buttons
   │  ├─ Hover highlights menu items
   │  └─ Button hit detection for Play Again, Main Menu, Resume, Restart, Quit
   │
   ├─ find_asset() - Flexible asset loader
   │  └─ Tries multiple paths: ./assets/, assets/, ../assets/, or raw filename
   │
   ├─ load_highscore() / save_highscore()
   │  ├─ Reads/writes highscore.txt (plain text integer)
   │  └─ Fails gracefully if file missing (returns 0 on load)
   │
   └─ check_collision() - AABB hitbox overlap with inset
      └─ Shrinks each box by 12% before checking overlap (makes collisions feel fair)

3. PLAYER (src/player.c)
   Structure:
   ├─ Position: x, y (top-left corner)
   ├─ Size: width (~67.5), height (~81)
   ├─ Physics: velocity_x, velocity_y, angle (radians), max_speed
   └─ Sprite: GdkPixbuf pointer (car_rotated.png scaled at render time)
   
   Key functions:
   ├─ player_new() - Create player at start position
   ├─ player_update() - Apply friction, clamp speed, update position, enforce bounds
   ├─ player_move_left/right() - Rotate angle left/right
   ├─ player_move_up/down() - Add forward/backward acceleration
   ├─ player_draw() - Render car sprite (or fallback red car if no sprite)
   └─ player_free() - Clean up
   
   Movement model:
   └─ Car rotates to face the direction you want (TURN_SPEED = 7 rad/s)
      Acceleration applies force in facing direction (500 units/s²)
      Friction damps velocity exponentially (3 damping/s)
      Max speed clamped to 800 units/s

4. OBSTACLES (src/obstacle.c)
   Structure:
   ├─ Obstacle: x, y, width, height, velocity, sprite, active flag
   └─ ObstacleManager: array of obstacles, spawn_timer, spawn_interval, speed, sprite_templates
   
   Key functions:
   ├─ obstacle_manager_new() - Initialize manager, seed RNG
   ├─ obstacle_manager_spawn() - Create new obstacles every spawn_interval seconds
   │  ├─ Randomly picks small/fast, medium, or large/slow type
   │  ├─ Randomly selects from sprite_templates (4 obstacle variants)
   │  └─ Spawns at random X, top of screen
   │
   ├─ obstacle_manager_update() - Move obstacles down; mark off-screen as inactive
   ├─ obstacle_manager_draw() - Render each obstacle (sprite or fallback red rect)
   └─ obstacle_manager_free() - Clean up
   
   Spawn logic (at game reset):
   ├─ Base spawn_interval = 1.5 seconds (applies SPEEDUP_FACTOR: 1.5 / 1.25 = 1.2s)
   ├─ Base obstacle_speed = 250 px/s (applies SPEEDUP_FACTOR: 250 * 1.25 = 312.5 px/s)
   ├─ Type 0: 40x40 px, 1.4x speed
   ├─ Type 1: 54x54 px, 1x speed
   └─ Type 2: 94.5x67.5 px (scaled by 1.35), 0.75x speed
   
   Progressive difficulty:
   └─ Every 1000 points: obstacle_speed += 50, spawn_interval *= 0.9

5. GRAPHICS (src/graphics.c)
   Functions:
   ├─ Color management (predefined colors: BLACK, WHITE, RED, BLUE, YELLOW, etc.)
   ├─ Basic drawing: rectangles, circles, text (with/without shadow)
   ├─ graphics_load_image() - Loads PNG via gdk_pixbuf_new_from_file()
   │  └─ Falls back to solid-color pixbuf if file missing (game continues)
   │
   ├─ graphics_draw_pixbuf() - Scales and renders pixbuf to cairo
   ├─ graphics_draw_text_with_shadow() - Renders text with black shadow for readability
   └─ graphics_clear_canvas() - Fill with color
   
   Asset loading:
   └─ Uses find_asset() to locate images in ./assets/, assets/, ../assets/, or cwd

GAME FLOW
=========

1. APPLICATION START
   ├─ main() creates GTK window and Game struct
   ├─ game_init() loads all images, connects event handlers
   ├─ game_start() shows window and starts 60 FPS loop
   └─ Player sees main menu

2. MAIN MENU
   ├─ Options: Start Game, Controls, Quit
   ├─ Keyboard: Arrow Up/Down to select, Space/Enter to activate
   ├─ Mouse: Hover over button highlights it, click to activate
   ├─ Selecting "Start Game": game_reset(), screen_state = PLAYING
   ├─ Selecting "Controls": screen_state = CONTROLS (shows instructions)
   ├─ Selecting "Quit": game_stop() (exit)

3. CONTROLS SCREEN
   ├─ Displays arrow key and button controls
   ├─ Press Space/Enter to return to menu

4. PLAYING
   ├─ Player controls car with arrow keys (Left/Right rotate, Up accelerate, Down brake)
   ├─ Background scrolls down at BG_SCROLL_SPEED (150 px/s after speedup)
   ├─ Obstacles spawn every ~1.2 seconds and fall down
   ├─ Score accumulates at SCORE_RATE_BASE (75 pts/s after speedup)
   ├─ Player car sprite rotates to match angle
   ├─ If collision: game_update() detects it, saves high score if beaten, screen_state = GAME_OVER
   ├─ If ESC or P pressed: game_pause(), screen_state = PAUSED
   └─ Level increases every 1000 points (obstacles get faster/spawn more)

5. PAUSE MENU
   ├─ Semi-transparent overlay dims background
   ├─ Options: Resume, Restart, Main Menu, Quit (buttons and keyboard)
   ├─ Click/press Resume or Space: game_resume(), screen_state = PLAYING (continues from pause)
   ├─ Click/press Restart: game_reset(), screen_state = PLAYING (new game)
   ├─ Click/press Main Menu: screen_state = MENU
   ├─ Click/press Quit or ESC: game_stop() (exit)
   └─ Game objects (player, obstacles) stay unchanged during pause; physics only updates when PLAYING

6. GAME OVER
   ├─ Displays: "GAME OVER", final score, high score, "NEW HIGH SCORE!" if beat record
   ├─ Buttons: "Play Again" (restarts), "Main Menu" (returns to menu)
   ├─ Keyboard: Space to restart, ESC to menu
   └─ High score persisted to highscore.txt if beaten

KEY GAME MECHANICS
==================

COLLISION DETECTION:
├─ Simple AABB (axis-aligned bounding box) overlap test
├─ Player hitbox: inset 12% from sprite bounds (shrinks slightly)
├─ Obstacle hitbox: inset 12% from sprite bounds
├─ Inset reduces perceived "early" collisions; makes collisions feel fair
└─ When collision detected: score saved if new high, screen switches to GAME_OVER

EXPONENTIAL DIFFICULTY SYSTEM:
├─ The game uses exponential scaling formulas to increase difficulty smoothly
├─ Three main exponential factors update each frame:
│
│  1. SPEED MULTIPLIER:
│     └─ Formula: speed_mult = (1 + score/2000)^1.5, capped at 3x
│        - Obstacles move faster and background scrolls faster
│        - At score 1000: ~1.8x speed
│        - At score 2000: ~2.8x speed
│        - At score 5000: 3.0x (capped)
│
│  2. SPAWN MULTIPLIER (spawn rate acceleration):
│     └─ Formula: spawn_mult = 1 / (1 + score/1500)^1.2
│        - Smaller spawn interval means obstacles appear more frequently
│        - At score 1000: ~1.4x faster spawning
│        - At score 2000: ~2.1x faster spawning
│        - Minimum interval capped at 0.3 seconds to prevent impossibility
│
│  3. SCORE MULTIPLIER (reward scaling):
│     └─ Formula: score_mult = 1 + (score/3000)^0.8, capped at 4.0x
│        - Higher score rates as difficulty increases, rewarding players
│        - Displayed on HUD as "x2.5" next to current score
│        - At score 1000: ~1.6x multiplier
│        - At score 3000: ~2.0x multiplier
│        - At score 5000: ~2.6x multiplier
│
├─ DIFFICULTY STAGES (5 levels):
│  ├─ Stage 1 (EASY):        0-500 points    - Base difficulty
│  ├─ Stage 2 (MEDIUM):   500-1500 points    - Speed ramps up, gaps tighten
│  ├─ Stage 3 (HARD):    1500-3000 points    - Fast speed, tight obstacles
│  ├─ Stage 4 (VERY HARD): 3000-5000 points - Very fast, challenging patterns
│  └─ Stage 5 (EXTREME):   5000+ points     - Maximum speed, intense gameplay
│
├─ Each stage transition is announced in game logs (g_debug)
├─ Difficulty stage displayed on HUD at top-right
└─ No sudden spikes; difficulty increases smoothly and predictably

SCORING SYSTEM (WITH EXPONENTIAL MULTIPLIER):
├─ Base points accumulate continuously at SCORE_RATE_BASE (75 pts/s at 25% speedup)
├─ Actual points awarded: base_rate * score_multiplier
├─ At 0 points: 1.0x multiplier = 75 pts/s
├─ At 1000 points: 1.6x multiplier = 120 pts/s
├─ At 3000 points: 2.0x multiplier = 150 pts/s
├─ Rewards skilled play; higher scores are earned faster at higher difficulty
├─ Accumulator tracks fractional points; integer score incremented per full point
└─ High score file (highscore.txt) updated when beaten and persists between sessions

PROGRESSIVE DIFFICULTY:
├─ Every 1 point earned: difficulty recalculated (smooth exponential progression)
├─ Obstacles speed and spawn rates update in real-time
├─ No discrete jumps (unlike old system where difficulty jumped every 1000 points)
└─ Result: Constantly increasing challenge that feels natural and fair

MENU SYSTEMS
============

MAIN MENU:
├─ Title: "CAR GAME" in yellow, centered
├─ Subtitle: "Avoid the Red Obstacles!"
├─ Options (hover highlights, click selects):
│  ├─ Start Game (index 0)
│  ├─ Controls (index 1)
│  └─ Quit (index 2)
├─ Background: dark blue
├─ Footer: "Survive and avoid obstacles to score points!"
└─ Hover effect: semi-transparent yellow highlight over option

CONTROLS SCREEN:
├─ Displays: Arrow Keys, Space, ESC and their functions
├─ Background: dark blue
└─ Press Space/Enter to return to menu

PAUSE MENU:
├─ Title: "PAUSED" in yellow
├─ Buttons (click or key): Resume, Restart, Main Menu, Quit
├─ Background: semi-transparent dark overlay (60% black)
├─ Box: dark blue border, slight transparency
└─ Buttons can be clicked or activated via keyboard/ESC

GAME OVER MENU:
├─ Title: "GAME OVER" in red (large, bold)
├─ Displays:
│  ├─ "Final Score: <score>" (yellow)
│  ├─ "High Score: <highscore>" (white)
│  ├─ "NEW HIGH SCORE!" if beaten (yellow, only if true)
├─ Buttons (click or key): "Play Again", "Main Menu"
├─ Background: dark red tint
└─ "Try to beat your score next time!" footer

FILE HANDLING
=============

HIGH SCORE PERSISTENCE:
├─ File: highscore.txt (plain text, one integer)
├─ Location: Current working directory (build/ when run from shortcut)
├─ On game_init(): load_highscore() reads file (returns 0 if missing)
├─ On collision (game over): if current_score > highscore, save_highscore() writes
├─ Load/save functions: Gracefully handle missing files or read errors
└─ No crash if file can't be written (game continues)

IMAGE ASSETS:
├─ All images loaded at game_init() via find_asset()
├─ find_asset() tries paths: ./assets/, assets/, ../assets/, then raw name
├─ On missing image: graphics_load_image() creates solid-color fallback pixbuf
├─ Images scaled on-demand when drawn (no pre-scaling), then cached briefly
├─ On cleanup (game_cleanup()): all pixbufs unreferenced

GRAPHICS & RENDERING SYSTEM
============================

IMAGE LOADING:
├─ find_asset(name) - Locates image in multiple candidate paths
├─ graphics_load_image(filename) - Loads PNG to GdkPixbuf
│  └─ Returns fallback pixbuf (64x64 solid color) if file missing
└─ Player sprite (car_rotated.png) scaled at render time to player->width/height

DRAWING:
├─ draw_callback() called after every frame update (GTK+ signals)
├─ Background: drawn first (scrolls seamlessly via two tiled copies)
├─ Game objects: player and obstacles drawn on top
├─ HUD: score text with shadow for readability (left-aligned, top)
├─ Menus: drawn as overlays (main menu, pause, game over, controls)
└─ All coordinates in screen pixels (800x600 window)

TEXT RENDERING:
├─ graphics_draw_text() - Plain text
├─ graphics_draw_text_with_shadow() - Text with black shadow (HUD readability)
├─ graphics_draw_text_centered() - Centered text
├─ Font: "sans-serif" (GTK+ default, system font)
└─ Shadow: 2px offset, 60% black, then white text on top

BACKGROUND SCROLLING:
├─ Static variable: bg_scroll (advances each frame while PLAYING)
├─ Speed: BG_SCROLL_SPEED = 150 px/s (120 * 1.25)
├─ Each frame: bg_scroll += BG_SCROLL_SPEED * dt
├─ Render: two copies of background_image tiled vertically
│  ├─ One at y = -GAME_HEIGHT + (bg_scroll % GAME_HEIGHT)
│  └─ One at y = bg_scroll % GAME_HEIGHT
└─ Result: seamless downward scroll (simulates road/track moving)

CONTROLS
========

KEYBOARD (In-Game / Gameplay):
├─ Left / Right Arrow: Rotate car left/right
├─ Up Arrow: Accelerate forward in facing direction
├─ Down Arrow: Brake (negative acceleration)
├─ Space: Pause game (or restart from game over)
├─ ESC: Pause game
├─ P: Toggle pause/resume
├─ Enter: Treat as Space

KEYBOARD (Menus):
├─ Up / Down Arrow: Select menu item
├─ Space / Enter: Activate selected item
├─ ESC: Go back / Quit

MOUSE (All Menus):
├─ Click menu button: Activate immediately
├─ Hover over button: Highlights via motion-notify-event

FEATURES SUMMARY
================

✓ Smooth 60 FPS gameplay loop
✓ Player car with sprite-based rendering and rotation
✓ Multiple obstacle types (4 variants) spawning randomly
✓ Realistic collision detection with inset hitboxes
✓ Score accumulation (frame-rate independent)
✓ High score saving/loading (highscore.txt)
✓ Progressive difficulty (speed increases every 1000 points)
✓ Main menu with mouse/keyboard support
✓ Pause menu with full options
✓ Game over screen with score display
✓ Controls instruction screen
✓ Scrolling background with seamless looping
✓ Button hover effects and mouse support
✓ Keyboard and mouse input support in menus
✓ Graceful fallback for missing images
✓ Comprehensive error handling

HOW TO RUN
==========

EXECUTABLE:
├─ Double-click: C:\Users\User\Desktop\Car Game.lnk (Desktop shortcut)
└─ Or: C:\Users\User\Desktop\PF LAB project\build\car_game.exe

FROM SOURCE (Requires MSYS2 MinGW and GTK3 dev files):
├─ Open MSYS2 MINGW64 shell
├─ cd '/c/Users/User/Desktop/PF LAB project'
├─ bash build/compile.sh
└─ ./build/car_game.exe

BUILD SCRIPT (Windows batch, requires bash.exe in PATH):
├─ .\rebuild_and_test.bat (runs compile.sh and launches game)

HOW TO MODIFY
=============

CHANGE GAME SPEED:
├─ Edit: src/game.c, line with SPEEDUP_FACTOR
├─ Increase value (e.g., 1.5) for faster, decrease (e.g., 1.0) for normal
└─ Rebuild: bash build/compile.sh

ADJUST PLAYER MOVEMENT:
├─ Edit: src/player.c, TURN_SPEED, ACCELERATION, BRAKE_FORCE, MAX_SPEED
├─ TURN_SPEED: radians per second (7.0 = moderate turning)
├─ ACCELERATION: units per second squared (500.0 = moderate accel)
└─ Rebuild

CHANGE COLLISION INSET:
├─ Edit: src/game.c, check_collision() function, INSET_RATIO
├─ Increase (e.g., 0.2) for larger inset (easier to dodge)
├─ Decrease (e.g., 0.05) for tighter collisions
└─ Rebuild

ADJUST DIFFICULTY PROGRESSION:
├─ Edit: src/game.c, game_update() function
├─ Change "1000" to spawn level-up at different score
├─ Change "50.0" to adjust speed increase per level
├─ Change "0.9" to adjust spawn rate acceleration
└─ Rebuild

ADD NEW OBSTACLE VARIANT:
├─ Add PNG image to assets/
├─ Edit: src/game.c, game_init() to load new image with find_asset()
├─ Add to obstacle_manager->sprite_templates in game_reset()
└─ Rebuild (obstacle_manager_spawn() will randomly pick from templates)

CHANGE BACKGROUND IMAGE:
├─ Replace: assets/background-1.png with your image
├─ Or edit src/game.c to load different filename in game_init()
└─ Rebuild

REBUILD INSTRUCTIONS
====================

Prerequisites:
├─ MSYS2 with MinGW64 and development packages installed
├─ GTK+3 development files (usually: pacman -S mingw-w64-x86_64-gtk3)
└─ pkg-config and gcc available in MSYS2

Quick Rebuild:
├─ Open MSYS2 MINGW64 shell
├─ cd '/c/Users/User/Desktop/PF LAB project'
├─ bash build/compile.sh
└─ If successful: ./build/car_game.exe

Troubleshooting:
├─ "car_game.exe: Permission denied" - Close running game, then rebuild
├─ "GTK+3 not found" - Install: pacman -S mingw-w64-x86_64-gtk3
├─ "gcc not found" - Install: pacman -S base-devel
└─ See build status at end of compile.sh output (0 = success, non-0 = error)

SUMMARY
=======

This is a complete C-based racing game using GTK3 and Cairo for graphics. The
codebase is modular (game, player, obstacle, graphics modules), uses a standard
game loop pattern (update → collision → render), and handles UI via GTK events.
The game supports both keyboard and mouse input, persists high scores, and
provides smooth gameplay at 60 FPS.

The code is well-commented, structured for maintainability, and includes
features like progressive difficulty, sprite-based graphics, collision
detection with fair hitboxes, and comprehensive menu systems.

For further modifications or questions, refer to the specific source files
(main.c, game.c, player.c, obstacle.c, graphics.c) which contain detailed
comments on each function.

================================================================================
